{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Eamon Chen","url":"http://eamon.xyz"},"pages":[{"title":"tags","date":"2018-03-24T14:39:23.000Z","updated":"2018-03-24T14:47:22.662Z","comments":false,"path":"tags/index.html","permalink":"http://eamon.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"整理粒子特效资源工具","slug":"整理粒子特效资源工具","date":"2018-04-27T13:22:29.000Z","updated":"2018-04-27T14:18:57.854Z","comments":true,"path":"2018/04/27/整理粒子特效资源工具/","link":"","permalink":"http://eamon.xyz/2018/04/27/整理粒子特效资源工具/","excerpt":"","text":"粒子特效资源管理混乱是让人很头疼的问题，虽说可以制定规范让特效师按照要求放置资源，但是到了后期资源增删改次数多了垃圾资源也会沉淀在项目中。亦或者特效师一次性提交了很多个特效预设，程序其实也是没时间验收特效的引用资源数，这样特效师就能为所欲为。 为此，在牺牲一点包体容量的前提下，将一个特效预设引用的所有资源都单独拿出来放到一个文件夹中。由于资源和特效预设都是在一个AssetBundle内的，这样加载特效资源也不会加入一些不需要使用的资源。 实现原理： 1、将这个预设所有用到的资源（材质、纹理、网格、状态机控制器、动画）都复制一份到一个新建的文件夹内。 2、将这些复制出来的资源重新组织他们联系。 脚本使用方式： .jpg) 选中一个或者批量选中粒子特效右键。 1、NewPrefab：重新拷贝一份新的预设组织新的资源。 2、ReplacePrefab：用原来的预设组织新的资源。 原始的特效资源视图： 整理过后的资源视图： 代码就不细述了，直接贴代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282using System.Collections.Generic;using UnityEngine;using UnityEditor;using System.IO;using UObject = UnityEngine.Object;public class ParticleCollector : MonoBehaviour&#123; public static Dictionary&lt;string, UObject&gt; cloneCacheDic = new Dictionary&lt;string, UObject&gt;(); public static bool isReplaceMode = false; [MenuItem(&quot;Assets/ParticleCollector/NewPrefab&quot;)] static void NewPrefab() &#123; isReplaceMode = false; Collector(); &#125; [MenuItem(&quot;Assets/ParticleCollector/ReplacePrefab&quot;)] static void ReplacePrefab() &#123; isReplaceMode = true; Collector(); &#125; static void Collector() &#123; UObject[] arr = Selection.GetFiltered(typeof(UObject), SelectionMode.TopLevel); UObject[] fileList = new UObject[arr.Length]; int count = 0; for (int i = 0; i &lt; arr.Length; i++) &#123; UObject obj = arr[i]; string fileStr = AssetDatabase.GetAssetPath(arr[i]); if (fileStr.EndsWith(&quot;.prefab&quot;)) &#123; fileList[count] = obj; ++count; &#125; &#125; if (count &gt; 0) &#123; ExecuteFiles(fileList); &#125; &#125; /// &lt;summary&gt; /// 处理文件 /// &lt;/summary&gt; /// &lt;param name=&quot;obj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;filePath&quot;&gt;&lt;/param&gt; static void ExecuteFile(UObject obj, string filePath) &#123; cloneCacheDic.Clear(); DirectoryInfo dirInfo = new DirectoryInfo(filePath); DirectoryInfo parentDirInfo = dirInfo.Parent; //新建文件夹 string newFolderName = Path.GetFileNameWithoutExtension(filePath); DirectoryInfo newDirInfo = Directory.CreateDirectory(Path.Combine(parentDirInfo.FullName, newFolderName)); GameObject newPrefab; //拷贝prefab文件 if (isReplaceMode) &#123; newPrefab = obj as GameObject; &#125;else &#123; newPrefab = CloneObject&lt;GameObject&gt;(obj as GameObject, newDirInfo.FullName); &#125; //处理绑定信息 ExecuteBind(newPrefab, newDirInfo.FullName); Debug.Log(&quot;dofile&quot; + parentDirInfo.FullName + &quot;--&gt;&quot; + newDirInfo.FullName + &quot;--&gt;&quot; + newFolderName); &#125; /// &lt;summary&gt; /// 处理其他额外绑定的组件 /// &lt;/summary&gt; /// &lt;param name=&quot;newPrefab&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;targetFolder&quot;&gt;&lt;/param&gt; static void ExecuteBind(GameObject newPrefab, string targetFolder) &#123; GameObject[] objTempArr = &#123; newPrefab &#125;; UObject[] objs = EditorUtility.CollectDependencies(objTempArr); string newPrefabPath = AssetDatabase.GetAssetPath(newPrefab); string objText = File.ReadAllText(newPrefabPath); int count = objs.Length; for (int dpIdx = 0; dpIdx &lt; objs.Length; dpIdx++) &#123; UObject tempObj = objs[dpIdx]; if (tempObj == null) continue; UpdateProgress(dpIdx, count, string.Format(&quot;处理依赖文件:&#123;0&#125;&quot;, tempObj.name)); System.Type t = tempObj.GetType(); if (t == typeof(Mesh)) &#123; objText = ExecuteMesh(tempObj, targetFolder, objText); &#125; else if (t == typeof(UnityEditor.Animations.AnimatorController)) &#123; objText = ExecuteAnimatorController(tempObj, targetFolder, objText); &#125; else if (t == typeof(Material)) &#123; objText = ExecuteMaterial(tempObj, targetFolder, objText); &#125; &#125; File.WriteAllText(newPrefabPath, objText); AssetDatabase.SaveAssets(); &#125; /// &lt;summary&gt; /// 处理材质 /// &lt;/summary&gt; /// &lt;param name=&quot;tempObj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;targetFolder&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;objText&quot;&gt;&lt;/param&gt; static string ExecuteMaterial(UObject tempObj, string targetFolder, string objText) &#123; Material mat = tempObj as Material; Material newMat = CloneObject&lt;Material&gt;(mat, targetFolder); if (newMat != null) &#123; //处理材质 objText = ReplaceGuid(objText, mat, newMat); //处理材质绑定的贴图 Material[] matArr = &#123; newMat &#125;; UObject[] depObsj = EditorUtility.CollectDependencies(matArr); string newMatPath = AssetDatabase.GetAssetPath(newMat); string newMatText = File.ReadAllText(newMatPath); for (int texIdx = 0; texIdx &lt; depObsj.Length; texIdx++) &#123; UObject tempTexObj = depObsj[texIdx]; if (tempTexObj.GetType() == typeof(Texture2D)) &#123; Texture2D tex = tempTexObj as Texture2D; Texture2D newTex = CloneObject&lt;Texture2D&gt;(tex, targetFolder); newMatText = ReplaceGuid(newMatText, tex, newTex); &#125; &#125; File.WriteAllText(newMatPath, newMatText); &#125; return objText; &#125; /// &lt;summary&gt; /// 处理动画状态机 /// &lt;/summary&gt; /// &lt;param name=&quot;tempObj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;targetFolder&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;objText&quot;&gt;&lt;/param&gt; static string ExecuteAnimatorController(UObject tempObj, string targetFolder, string objText) &#123; UnityEditor.Animations.AnimatorController aCtrl = tempObj as UnityEditor.Animations.AnimatorController; UnityEditor.Animations.AnimatorController newACtrl = CloneObject&lt;UnityEditor.Animations.AnimatorController&gt;(aCtrl, targetFolder); if (newACtrl != null) &#123; //处理状态机 objText = ReplaceGuid(objText, tempObj, newACtrl); //处理状态机绑定的动画 UnityEditor.Animations.AnimatorController[] acArr = &#123; newACtrl &#125;; UObject[] depObsj = EditorUtility.CollectDependencies(acArr); string newACtrlPath = AssetDatabase.GetAssetPath(newACtrl); string newACtrlText = File.ReadAllText(newACtrlPath); for (int animIdx = 0; animIdx &lt; depObsj.Length; animIdx++) &#123; UObject tempAnimObj = depObsj[animIdx]; if (tempAnimObj.GetType() == typeof(AnimationClip)) &#123; AnimationClip animClip = tempAnimObj as AnimationClip; AnimationClip newAnimClip = CloneObject&lt;AnimationClip&gt;(animClip, targetFolder); newACtrlText = ReplaceGuid(newACtrlText, animClip, newAnimClip); &#125; &#125; File.WriteAllText(newACtrlPath, newACtrlText); &#125; return objText; &#125; /// &lt;summary&gt; /// 处理网格 /// &lt;/summary&gt; /// &lt;param name=&quot;tempObj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;targetFolder&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;objText&quot;&gt;&lt;/param&gt; static string ExecuteMesh(UObject tempObj, string targetFolder, string objText) &#123; Mesh newMesh = CloneObject&lt;Mesh&gt;(tempObj as Mesh, targetFolder); if (newMesh != null) &#123; objText = ReplaceGuid(objText, tempObj, newMesh); //Debug.LogFormat(&quot;Dependencie--&gt; [&#123;0&#125;] [&#123;1&#125;] [&#123;2&#125;] &quot;, tempObj, meshGuid, newMeshGuid); &#125; return objText; &#125; /// &lt;summary&gt; /// 替换guid /// &lt;/summary&gt; /// &lt;param name=&quot;objText&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;oldObj&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;newObj&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; static string ReplaceGuid(string objText,UObject oldObj, UObject newObj) &#123; string oldObjPath = AssetDatabase.GetAssetPath(oldObj); string newObjPath = AssetDatabase.GetAssetPath(newObj); string oldGuid = AssetDatabase.AssetPathToGUID(oldObjPath); string newGuid = AssetDatabase.AssetPathToGUID(newObjPath); if(oldGuid == null || newGuid == null) &#123; Debug.LogErrorFormat(&quot;ReplaceGuid error oldGuid = &#123;0&#125; newTexGuid = &#123;1&#125; oldObjPath = &#123;2&#125; newObjPath = &#123;3&#125; oldObj = &#123;4&#125; newObj = &#123;5&#125;&quot;, oldGuid, newGuid, oldObjPath, newObjPath, oldObj, newObj); return objText; &#125;else &#123; return objText.Replace(oldGuid, newGuid); &#125; &#125; /// &lt;summary&gt; /// 克隆文件对象 /// &lt;/summary&gt; /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt; UnityEngine.Object /// &lt;param name=&quot;srcObj&quot;&gt;&lt;/param&gt; 原始文件对象 /// &lt;param name=&quot;targetFolder&quot;&gt;&lt;/param&gt;拷贝目标文件夹路径 /// &lt;returns&gt;&lt;/returns&gt; static T CloneObject&lt;T&gt;(T srcObj, string targetFolder) where T : UObject &#123; string srcFilePath = AssetDatabase.GetAssetPath(srcObj); Debug.LogFormat(&quot;Clone Object [&#123;0&#125;] [&#123;1&#125;] [&#123;2&#125;]&quot;, srcObj, srcFilePath, targetFolder); if (cloneCacheDic.ContainsKey(srcFilePath)) &#123; Debug.LogFormat(&quot;Object is exist [&#123;0&#125;] [&#123;1&#125;]&quot;, srcObj, srcFilePath); return cloneCacheDic[srcFilePath] as T; &#125; if (srcFilePath.IndexOf(&quot;_builtin&quot;) != -1 || srcFilePath.IndexOf(&quot;Library&quot;) != -1 || srcFilePath.IndexOf(&quot;No Name&quot;) != -1) &#123; Debug.LogFormat(&quot;Clone Object failed object is builtin resource [&#123;0&#125;] [&#123;1&#125;]&quot;, srcObj, srcFilePath); return null; &#125; string fileName = Path.GetFileName(srcFilePath); string newPath = Path.Combine(targetFolder, fileName); AssetDatabase.CopyAsset(srcFilePath, newPath); string loadPrefabPath = newPath.Substring(Application.dataPath.Length - &quot;Assets&quot;.Length); T newObj = AssetDatabase.LoadAssetAtPath&lt;T&gt;(loadPrefabPath); cloneCacheDic.Add(srcFilePath, newObj); return newObj; &#125; static void ExecuteFiles(UObject[] fileList) &#123; try &#123; int count = fileList.Length; for (int i = 0; i &lt; count; i++) &#123; UObject obj = fileList[i]; if (obj != null) &#123; string filePath = AssetDatabase.GetAssetPath(obj); UpdateProgress(i, count, string.Format(&quot;正在处理文件:&#123;0&#125;&quot;,filePath)); ExecuteFile(obj, filePath); &#125; &#125; AssetDatabase.Refresh(); EditorUtility.ClearProgressBar(); &#125; catch (System.Exception) &#123; EditorUtility.ClearProgressBar(); throw; &#125; &#125; static void UpdateProgress(int progress, int progressMax, string desc) &#123; string title = &quot;Processing...[&quot; + progress + &quot; - &quot; + progressMax + &quot;]&quot;; float value = (float)progress / (float)progressMax; EditorUtility.DisplayProgressBar(title, desc, value); &#125;&#125;","categories":[{"name":"Unity","slug":"Unity","permalink":"http://eamon.xyz/categories/Unity/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://eamon.xyz/tags/Unity/"}],"keywords":[{"name":"Unity","slug":"Unity","permalink":"http://eamon.xyz/categories/Unity/"}]},{"title":"（十四）漫反射光","slug":"（十四）漫反射光","date":"2018-03-10T13:43:34.000Z","updated":"2018-04-22T10:52:23.275Z","comments":true,"path":"2018/03/10/（十四）漫反射光/","link":"","permalink":"http://eamon.xyz/2018/03/10/（十四）漫反射光/","excerpt":"","text":"漫反射光是根据物体表面的法线和入射光的方向进行计算得出光照强度，光照如下图所示： 当L（光照方向）和N（法线方向）重合时光照强度将会达到最大，夹角越大则强度越小。那么我们可以用角度的余弦值来描述光照的强度，那么就能得出光照强度的表达式：$$Diffuse = DiffuseColor(漫反射光颜色) Intensity(漫反射光的强度) dot(L,N)$$然而L和N的角度可能超过90度，这时候需要将光线强度变为零，那么公式应该变成：$$Diffuse=DiffuseColor(漫反射光颜色) Intensity(漫反射光的强度) max(0, dot(L,N))$$接下来用Shader实现漫反射的效果，新建diffuse.vs和diffuse.fs。123456789101112131415161718192021//diffuse.vsattribute vec4 position;//从外部传过来的顶点坐标attribute vec2 texcoord;//从外部传过来的纹理坐标attribute vec4 normal;//从外部传过来的法线uniform mat4 modelMatrix;//从外部传过来的全局变量模型矩阵uniform mat4 viewMatrix;//从外部传过来的全局变量视矩阵uniform mat4 projectionMatrix;//从外部传过来的全局变量投影矩阵uniform mat4 IT_ModelMatrix;//从外部传过来的全局变量法线模型矩阵矩阵varying vec2 V_Texcoord;//输出到片元的属性，顶点坐标varying vec4 V_WorldNormal;//输出到片元的属性，世界空间的法线void main()&#123; //gl_Position是用来传递顶点坐标的 裁剪空间的坐标 = MVP * position gl_Position= projectionMatrix * viewMatrix * modelMatrix * position; //赋值给varying变量，这个值可以在fs中获得到 V_Texcoord = texcoord; //模型空间法线转换到世界空间法线 V_WorldNormal = IT_ModelMatrix * normal;&#125; 12345678910111213141516171819202122232425//兼容OpenGL ES 定义数值精度为mediump#ifdef GL_ESprecision mediump float;#endifuniform vec4 U_AmbientColor;//环境光颜色uniform vec4 U_AmbientIntensity;//环境光强度uniform vec4 U_DiffuseColor;//漫反射光颜色uniform vec4 U_DiffuseIntensity;//漫反射光强度uniform vec4 U_LightPos;uniform sampler2D U_Texture;//从外部传过来的纹理采样器varying vec2 V_Texcoord; //接收vs传过来的值，纹理坐标varying vec4 V_WorldNormal;//接收vs传过来的值，世界空间的法线void main()&#123; //环境光照计算 vec4 ambient = U_AmbientColor * U_AmbientIntensity; //光线的单位向量 vec3 L = normalize(U_LightPos.xyz); //顶点的世界法线单位向量 vec3 N = normalize(V_WorldNormal.xyz); //漫反射光计算 vec4 diffuse = U_DiffuseColor * U_DiffuseIntensity * max(0, dot(L, N)); //内置变量 设置最后该像素的颜色值 gl_FragColor = diffuse;&#125; Shader需要的几个变量要在C#内传到GPU内，在DrawModelScene.cpp内修改下。 12345678910111213141516171819202122//DrawModelScene.cppvoid DrawModelScene::Init()&#123; vec3 eysPos(0.0f, 0.0f, 5.0f);//眼睛的位置 vec3 target(0.0f, 0.0f, 0.0f);//目标位置 vec3 upDir(0.0f, 1.0f, 0.0f);//上方坐标 //计算出视矩阵 mViewMatrix = glm::lookAt(eysPos, target, upDir); //计算出投影矩阵 mProjectionMatrix = glm::perspective(50.0f, 800.0f / 600.0f, 0.1f, 1000.0f); //初始化模型对象 mModel = new Model; mModel-&gt;Init(\"Res/Sphere.obj\",\"Res/Shader/diffuse.vs\",\"Res/Shader/diffuse.fs\"); mModel-&gt;SetTextureWithPath(\"Res/earth.bmp\"); mModel-&gt;SetPosition(0.0f, 0.0f, -1.0f); mModel-&gt;mShader-&gt;SetUniformVec4(\"U_AmbientColor\", 1.0f, 1.0f, 1.0f, 1.0f); mModel-&gt;mShader-&gt;SetUniformVec4(\"U_AmbientIntensity\", 0.1f, 0.1f, 0.1f, 1.0f); mModel-&gt;mShader-&gt;SetUniformVec4(\"U_DiffuseColor\", 1.0f, 1.0f, 1.0f, 1.0f); mModel-&gt;mShader-&gt;SetUniformVec4(\"U_DiffuseIntensity\", 0.6f, 0.6f, 0.6f, 1.0f); mModel-&gt;mShader-&gt;SetUniformVec4(\"U_LightPos\", 1.0f, 1.0f, 0.0f, 1.0f);//灯光位置&#125; 最后的效果图：","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（十三）环境光","slug":"（十三）环境光","date":"2018-03-03T08:12:22.000Z","updated":"2018-04-21T14:25:38.334Z","comments":true,"path":"2018/03/03/（十三）环境光/","link":"","permalink":"http://eamon.xyz/2018/03/03/（十三）环境光/","excerpt":"","text":"在现实世界中，没有光我们将看不见任何东西，你所看见的物体或者是反射了光源的光或者是本身就能自发光。环境光是所有光照模型中最简单的一种，然而在实时渲染中我们也不能完全复现现实生活中完全靠物体反射形成的环境光。因此我们需要模拟计算，得到一个近似的效果。环境光的定义：是一直微弱无方向的光。那么可以得出近似的光照表达式：$$Ambient = AmbientColor(环境光颜色) * Intensity(环境光的强度)$$新建ambient.vs和ambient.fs，在模型上实现接收环境光，为了方便看效果将模型贴图暂时去掉了。 123456789101112131415161718192021//ambient.vsattribute vec4 position;//从外部传过来的顶点坐标attribute vec2 texcoord;//从外部传过来的纹理坐标attribute vec4 normal;//从外部传过来的法线uniform mat4 modelMatrix;//从外部传过来的全局变量模型矩阵uniform mat4 viewMatrix;//从外部传过来的全局变量视矩阵uniform mat4 projectionMatrix;//从外部传过来的全局变量投影矩阵uniform mat4 IT_ModelMatrix;//从外部传过来的全局变量法线模型矩阵矩阵varying vec2 V_Texcoord;//输出到片元的属性，顶点坐标varying vec4 V_WorldNormal;//输出到片元的属性，世界空间的法线void main()&#123; //gl_Position是用来传递顶点坐标的 裁剪空间的坐标 = MVP * position gl_Position= projectionMatrix * viewMatrix * modelMatrix * position; //赋值给varying变量，这个值可以在fs中获得到 V_Texcoord = texcoord; //模型空间法线转换到世界空间法线 V_WorldNormal = IT_ModelMatrix * normal;&#125; 123456789101112131415161718//ambient.fs//兼容OpenGL ES 定义数值精度为mediump#ifdef GL_ESprecision mediump float;#endifuniform vec4 U_AmbientColor;//环境光颜色uniform vec4 U_AmbientIntensity;//环境光强度uniform sampler2D U_Texture;//从外部传过来的纹理采样器varying vec2 V_Texcoord; //接收vs传过来的值，纹理坐标varying vec4 V_WorldNormal;//接收vs传过来的值，世界空间的法线void main()&#123; //环境光照计算 vec4 ambient = U_AmbientColor * U_AmbientIntensity; //内置变量 设置最后该像素的颜色值 gl_FragColor= ambient;&#125; 在DrawModelScene.cpp中切换model的Shader 12345678910111213141516171819//DrawModelScene.cppvoid DrawModelScene::Init()&#123; vec3 eysPos(0.0f, 0.0f, 5.0f);//眼睛的位置 vec3 target(0.0f, 0.0f, 0.0f);//目标位置 vec3 upDir(0.0f, 1.0f, 0.0f);//上方坐标 //计算出视矩阵 mViewMatrix = glm::lookAt(eysPos, target, upDir); //计算出投影矩阵 mProjectionMatrix = glm::perspective(50.0f, 800.0f / 600.0f, 0.1f, 1000.0f); //初始化模型对象 mModel = new Model; mModel-&gt;Init(\"Res/Sphere.obj\",\"Res/Shader/ambient.vs\",\"Res/Shader/ambient.fs\"); mModel-&gt;SetTextureWithPath(\"Res/earth.bmp\"); mModel-&gt;SetPosition(0.0f, 0.0f, -1.0f); mModel-&gt;mShader-&gt;SetUniformVec4(\"U_AmbientColor\", 1.0f, 1.0f, 1.0f, 1.0f); mModel-&gt;mShader-&gt;SetUniformVec4(\"U_AmbientIntensity\", 0.1f, 0.1f, 0.1f, 1.0f);&#125; 运行之后可以看到模型只受环境光的效果。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（十二）封装Model类","slug":"（十二）封装Model类","date":"2018-02-10T08:12:22.000Z","updated":"2018-04-19T00:53:56.227Z","comments":true,"path":"2018/02/10/（十二）封装Model类/","link":"","permalink":"http://eamon.xyz/2018/02/10/（十二）封装Model类/","excerpt":"","text":"绘制3d模型跟2d的Sprite原理其实都是一样的，区别在于模型一般都是从磁盘读取解析出来，而Sprite代码写顶点就可以了；作为3d的元素模型还是有些不一样的功能，如透视、动作、光照计算等。 首先需要将模型文件加载到内存，然后按照顶点信息的组织结构提取出顶点、法线、纹理坐标等。这方面的文章有很多就不做详细介绍了，传送门。 模型资源：https://pan.baidu.com/s/1m_uCUFoYeZ2rxqrtPqKgdg 四边形可以说是最简单的模型，打开Quad.obj可以发现一堆数据，还好不是乱码，还是有规律可循。 123456789101112131415161718192021# This file uses centimeters as units for non-parametric coordinates.mtllib Quad.mtlg defaultv -0.500000 -0.500000 0.000000v 0.500000 -0.500000 0.000000v -0.500000 0.500000 0.000000v 0.500000 0.500000 0.000000vt 0.000000 0.000000vt 1.000000 0.000000vt 0.000000 1.000000vt 1.000000 1.000000vn 0.000000 0.000000 1.000000vn 0.000000 0.000000 1.000000vn 0.000000 0.000000 1.000000vn 0.000000 0.000000 1.000000s 1g Quadusemtl initialShadingGroupf 1/1/1 2/2/2 3/3/3f 3/3/3 2/2/2 4/4/4 https://blog.csdn.net/u010006851/article/details/52929100以#开始的行为注释行 usemtl和mtllib表示的材质相关数据 o 引入一个新的object v 表示顶点位置 vt 表示顶点纹理坐标 vn 表示顶点法向量 f 表示一个面，面使用1/1/1这样格式，表示顶点位置/纹理坐标/法向量的索引，这里索引的是前面用v,vt,vn定义的数据 注意这里Obj的索引是从1开始的，而不是0 有了顶点信息之后，后续过程就是跟Sprite的实现方式几乎一样，那么新建Model类，开始动手解析模型文件。 123456789101112131415161718192021222324252627282930313233//Model.h#pragma once#include \"utils.h\"#include \"Shader.h\"#include \"SceneManager.h\"#include &lt;sstream&gt;#include &lt;vector&gt;struct VertexData&#123; float position[3]; float normal[3]; float texcoord[2];&#125;;class Model&#123;private: VertexBuffer *mVertexBuffer; mat4 mModelMatrix; const char *mVSPath; const char *mFSPath;public: Shader *mShader; Model(); ~Model(); void Init(const char *path); void Init(const char *path,const char *vs, const char * fs); void Draw(); void SetPosition(float x, float y, float z); void SetModelMatrix(mat4 &amp;modelMatrix); void SetTextureWithPath(const char *texturePath); void SetTexture(GLuint texture);&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165//Model.cpp#include \"Model.h\"struct FloatData&#123; float v[3];&#125;;struct VertexDefine&#123; int posIndex; int texcoordIndex; int normalIndex;&#125;;Model::Model():mVSPath(\"Res/Shader/model.vs\"),mFSPath(\"Res/Shader/model.fs\"), mModelMatrix(mat4(1.0f))&#123;&#125;Model::~Model()&#123; delete mShader; delete mVSPath; delete mFSPath; delete mVertexBuffer;&#125;void Model::Init(const char *path)&#123; int fileSize; unsigned char* fileContent = LoadFileContent(path,fileSize); if (fileContent == nullptr) return; std::stringstream ssFileContent((char*)fileContent); vector&lt;FloatData&gt; positions,texcoords,normals; vector&lt;VertexDefine&gt; vertexes; vector&lt;int&gt; indexes; std::string temp; char szOneLine[256]; while (!ssFileContent.eof()) &#123; memset(szOneLine, 0, 256); ssFileContent.getline(szOneLine, 256); if (strlen(szOneLine) &gt; 0) &#123; if (szOneLine[0] == 'v') &#123;//首字母为v可能是vt、vn、v std::stringstream ssOneLine(szOneLine); if (szOneLine[1] == 't') &#123;//读取纹理坐标 ssOneLine &gt;&gt; temp; FloatData floatData; ssOneLine &gt;&gt; floatData.v[0]; ssOneLine &gt;&gt; floatData.v[1]; texcoords.push_back(floatData); //printf(\"texcoord : %f,%f\\n\", floatData.v[0], floatData.v[1]); &#125; else if (szOneLine[1] == 'n') &#123;//读取法线 ssOneLine &gt;&gt; temp; FloatData floatData; ssOneLine &gt;&gt; floatData.v[0]; ssOneLine &gt;&gt; floatData.v[1]; ssOneLine &gt;&gt; floatData.v[2]; normals.push_back(floatData); //printf(\"normal : %f,%f,%f\\n\", floatData.v[0], floatData.v[1], floatData.v[2]); &#125; else &#123;//读取顶点位置 ssOneLine &gt;&gt; temp; FloatData floatData; ssOneLine &gt;&gt; floatData.v[0]; ssOneLine &gt;&gt; floatData.v[1]; ssOneLine &gt;&gt; floatData.v[2]; positions.push_back(floatData); //printf(\"position : %f,%f,%f\\n\", floatData.v[0], floatData.v[1], floatData.v[2]); &#125; &#125; else if (szOneLine[0] == 'f') &#123;//组织成三角面 std::stringstream ssOneLine(szOneLine); ssOneLine &gt;&gt; temp; std::string vertexStr; for (int i = 0; i &lt; 3; i++) &#123; ssOneLine &gt;&gt; vertexStr; size_t pos = vertexStr.find_first_of('/'); std::string posIndexStr = vertexStr.substr(0, pos); size_t pos2 = vertexStr.find_first_of('/', pos + 1); std::string texcoordIndexStr = vertexStr.substr(pos + 1, pos2 - 1 - pos); std::string normalIndexStr = vertexStr.substr(pos2 + 1, vertexStr.length() - 1 - pos2); VertexDefine vd; vd.posIndex = atoi(posIndexStr.c_str()); vd.texcoordIndex = atoi(texcoordIndexStr.c_str()); vd.normalIndex = atoi(normalIndexStr.c_str()); vertexes.push_back(vd); &#125; &#125; &#125; &#125; //顶点的个数 int vertexCount = (int)vertexes.size(); //初始化顶点buffer，开始转换到之前可以用的数据结构 mVertexBuffer = new VertexBuffer; mVertexBuffer-&gt;SetSize(vertexCount); for (int i = 0; i &lt; vertexCount;++i) &#123; auto vertex = vertexes[i]; float *temp = positions[vertex.posIndex - 1].v; mVertexBuffer-&gt;SetPosition(i, temp[0], temp[1], temp[2]); temp = texcoords[vertex.texcoordIndex - 1].v; mVertexBuffer-&gt;SetTexcoord(i, temp[0], temp[1]); temp = normals[vertex.normalIndex - 1].v; mVertexBuffer-&gt;SetNormal(i, temp[0], temp[1], temp[2]); &#125; delete fileContent; //初始化shader mShader = new Shader(); mShader-&gt;Init(mVSPath, mFSPath); //查找shader中的顶点、纹理坐标、法线的插槽 mShader-&gt;DetectAttribute(\"position\"); mShader-&gt;DetectAttribute(\"texcoord\"); mShader-&gt;DetectAttribute(\"normal\"); //设置MVP矩阵 mShader-&gt;SetUniformMat(\"modelMatrix\", glm::value_ptr(mModelMatrix)); mShader-&gt;SetUniformMat(\"viewMatrix\", SceneManager::GetInstance()-&gt;GetViewMatrixPtr()); mShader-&gt;SetUniformMat(\"projectionMatrix\", SceneManager::GetInstance()-&gt;GetProjectionMatrixPrt());&#125;void Model::Init(const char *path, const char *vs, const char * fs)&#123; mVSPath = vs; mFSPath = fs; Init(path);&#125;void Model::Draw()&#123; glEnable(GL_DEPTH_TEST);//开启深度测试 mVertexBuffer-&gt;Bind(); mShader-&gt;Bind(); //计算将法线从模型空间转换到世界空间下的矩阵 mat4 it = glm::inverseTranspose(mModelMatrix); mShader-&gt;SetUniformMat(\"IT_ModelMatrix\", value_ptr(it)); //绘制三角面 glDrawArrays(GL_TRIANGLES, 0, mVertexBuffer-&gt;mVertexCount); mVertexBuffer-&gt;Unbind(); glBindTexture(GL_TEXTURE_2D, 0);&#125;void Model::SetPosition(float x, float y, float z)&#123; mModelMatrix = glm::translate(x, y, z);&#125;void Model::SetModelMatrix(mat4 &amp;modelMatrix)&#123; mModelMatrix = modelMatrix;&#125;void Model::SetTextureWithPath(const char *texturePath)&#123; mShader-&gt;SetTextureWithPath(\"U_Texture\", texturePath);&#125;void Model::SetTexture(GLuint texture)&#123; mShader-&gt;SetTexture(\"U_Texture\", texture);&#125; 这里有段可能会比较让人费解，计算IT_ModelMatrix矩阵的作用是什么。难道法线不是应该和模型矩阵相乘就可以得到世界空间下的法线吗？看下图应该就能明白用意。 在模型空间下T和N向量是垂直的。 分别乘上ModelMatrix后得到的结果并不是垂直的，显然是存在问题的。那么不是乘上ModelMatrix应该乘什么？ $$(worldN_x,worldN_y,worldN_z,worldN_w) =\\boxed{(ModelMatrix^{-1})^T}*(objN_x,objN_y,objN_z,objN_w)$$看过表达式之后应该知道这个矩阵是什么，至于为什么是这个结果，传送门。 接下来就是shader，跟Sprite用的shader多了投影的步骤。 123456789101112131415161718192021//model.vsattribute vec4 position;//从外部传过来的顶点坐标attribute vec2 texcoord;//从外部传过来的纹理坐标attribute vec4 normal;//从外部传过来的法线uniform mat4 modelMatrix;//从外部传过来的全局变量模型矩阵uniform mat4 viewMatrix;//从外部传过来的全局变量视矩阵uniform mat4 projectionMatrix;//从外部传过来的全局变量投影矩阵uniform mat4 IT_ModelMatrix;//从外部传过来的全局变量法线模型矩阵矩阵varying vec2 V_Texcoord;//输出到片元的属性，顶点坐标varying vec4 V_WorldNormal;//输出到片元的属性，世界空间的法线void main()&#123; //gl_Position是用来传递顶点坐标的 裁剪空间的坐标 = MVP * position gl_Position= projectionMatrix * viewMatrix * modelMatrix * position; //赋值给varying变量，这个值可以在fs中获得到 V_Texcoord = texcoord; //模型空间法线转换到世界空间法线 V_WorldNormal = IT_ModelMatrix * normal;&#125; 123456789101112131415//model.fs//兼容OpenGL ES 定义数值精度为mediump#ifdef GL_ESprecision mediump float;#endifuniform sampler2D U_Texture;//从外部传过来的纹理采样器varying vec2 V_Texcoord; //接收vs传过来的值，纹理坐标varying vec4 V_WorldNormal;//接收vs传过来的值，世界空间的法线void main()&#123; //texture2D 内置函数 用于采样指定uv坐标下的纹理颜色 vec4 color = texture2D(U_Texture,V_Texcoord); //内置变量 设置最后该像素的颜色值 gl_FragColor= color;&#125; 虽然获得了世界空间下的法线，但是并没有使用到，这属性将会在光照计算中使用。 Model类封装好了，之后就是使用它绘制一个模型。新建DrawModelScene。 1234567891011121314//DrawModelScene.h#pragma once#include \"BaseScene.h\"#include \"Model.h\"class DrawModelScene : public BaseScene&#123; Model *mModel;public: DrawModelScene(); ~DrawModelScene(); void Init(); void Draw();&#125;; 123456789101112131415161718192021222324252627282930313233343536373839//DrawModelScene.cpp#include \"DrawModelScene.h\"DrawModelScene::DrawModelScene()&#123;&#125;DrawModelScene::~DrawModelScene()&#123; delete mModel;&#125;void DrawModelScene::Init()&#123; vec3 eysPos(0.0f, 0.0f, 5.0f);//眼睛的位置 vec3 target(0.0f, 0.0f, 0.0f);//目标位置 vec3 upDir(0.0f, 1.0f, 0.0f);//上方坐标 //计算出视矩阵 mViewMatrix = glm::lookAt(eysPos, target, upDir); //计算出投影矩阵 mProjectionMatrix = glm::perspective(50.0f, 800.0f / 600.0f, 0.1f, 1000.0f); //初始化模型对象 mModel = new Model; mModel-&gt;Init(\"Res/Sphere.obj\"); mModel-&gt;SetTextureWithPath(\"Res/earth.bmp\"); mModel-&gt;SetPosition(0.0f, 0.0f, -1.0f);&#125;void DrawModelScene::Draw()&#123; //清理背景颜色为黑色 glClearColor(0, 0, 0, 255); //清理颜色缓冲区和深度缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); mModel-&gt;Draw();&#125; 为了方便获取mViewMatrix和mProjectionMatrix两个变量，在BaseScene中定义它 123456789101112131415//BaseScene.h#pragma once#include \"Utils.h\"class BaseScene&#123;public: BaseScene(); virtual ~BaseScene(); virtual void Init() = 0; virtual void Draw() = 0; mat4 mViewMatrix; mat4 mProjectionMatrix;&#125;; 12345678910//BaseScene.cpp#include \"BaseScene.h\"BaseScene::BaseScene():mViewMatrix(mat4(1.0)),mProjectionMatrix(mat4(1.0))&#123;&#125;BaseScene::~BaseScene()&#123;&#125; 接下来在SceneManager里切换场景和提供获得mViewMatrix以及没ProjectionMatrix的方法。 1234567891011121314151617//SceneManager.h#pragma once#include \"BaseScene.h\"class SceneManager&#123;private: BaseScene *mCurrentScene;//当前运行的场景 SceneManager();public: static SceneManager* GetInstance();//场景管理类的实例 ~SceneManager(); void EnterScene(); void Draw(); float* GetViewMatrixPtr(); float* GetProjectionMatrixPrt();&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//SceneManager.cpp#include \"SceneManager.h\"#include \"TriangleScene.h\"#include \"VBOTriangleScene.h\"#include \"FirstShaderScene.h\"#include \"DrawSpriteScene.h\"#include \"DrawModelScene.h\"static SceneManager *mInstance = nullptr;SceneManager::SceneManager()&#123;&#125;SceneManager* SceneManager::GetInstance()&#123; if (mInstance == nullptr) &#123; mInstance = new SceneManager(); &#125; return mInstance;&#125;SceneManager::~SceneManager()&#123; delete mCurrentScene;&#125;void SceneManager::EnterScene()&#123; mCurrentScene = new DrawModelScene(); mCurrentScene-&gt;Init();&#125;void SceneManager::Draw()&#123; mCurrentScene-&gt;Draw();&#125;float* SceneManager::GetViewMatrixPtr()&#123; return value_ptr(mCurrentScene-&gt;mViewMatrix);&#125;float* SceneManager::GetProjectionMatrixPrt()&#123; return value_ptr(mCurrentScene-&gt;mProjectionMatrix);&#125; 不出意外的话，看到不再是那个猫头了。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（十一）封装Sprite类","slug":"（十一）封装Sprite类","date":"2018-02-03T13:31:34.000Z","updated":"2018-04-15T08:30:32.522Z","comments":true,"path":"2018/02/03/（十一）封装Sprite类/","link":"","permalink":"http://eamon.xyz/2018/02/03/（十一）封装Sprite类/","excerpt":"","text":"一直在画三角形，总会觉得看不到实用性，接下来自己动手用之前用过的GL API封装一个Sprite类。 在此之前我们先封装两个工具类，Shader和VertexBuffer类，为以后实现其他功能提供便利性。 首先引用一个数学库方便我们的计算，这里选择GLM。github地址：https://github.com/g-truc/glm 工程中使用的版本为：https://pan.baidu.com/s/1tnUjQuUkmXVxOlq5hgo7tA 在GlobalGL.h中添加引用就可以了 12345678910111213//GlobalGL.h#pragma once#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include \"glew.h\"#include &lt;gl/GL.h&gt;#include &lt;gl/GLU.h&gt;#include &lt;gl/glext.h&gt;#include \"Glm/glm.hpp\"#include \"Glm/ext.hpp\"using namespace glm;using namespace std; VertexBuffer类主要是将vbo的初始化和绘制每帧绑定数据的功能封装起来。 123456789101112131415161718192021222324252627282930313233//VertexBuffer.h#pragma once#include \"utils.h\"struct Vertex&#123; float position[4]; float color[4]; float texcoord[4]; float normal[4];&#125;;class VertexBuffer&#123;public: GLuint mVbo; Vertex *mVertexes; unsigned int mVertexCount; VertexBuffer(); VertexBuffer(int vertexCount); ~VertexBuffer(); void SetSize(int vertexCount); void SetPosition(size_t index, float x, float y, float z, float w = 1.0f); void SetColor(size_t index, float r, float g, float b, float a = 1.0f); void SetNormal(size_t index, float x, float y, float z); void SetTexcoord(size_t index, float x, float y); void Bind(); void Unbind(); Vertex&amp; Get(int index);private:&#125;; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//VertexBuffer.cpp#include \"VertexBuffer.h\"VertexBuffer::VertexBuffer()&#123; &#125;VertexBuffer::VertexBuffer(int vertexCount)&#123; SetSize(vertexCount);&#125;VertexBuffer::~VertexBuffer()&#123; delete mVertexes;&#125;void VertexBuffer::SetSize(int vertexCount)&#123; //设置顶点个数 mVertexCount = vertexCount; mVertexes = new Vertex[vertexCount]; memset(mVertexes, 0, sizeof(Vertex) * vertexCount);//初始化顶点数组 //创建vbo mVbo = CreateBufferObject(GL_ARRAY_BUFFER, sizeof(Vertex)*mVertexCount, GL_STATIC_DRAW, nullptr);&#125;void VertexBuffer::SetPosition(size_t index, float x, float y, float z, float w)&#123; mVertexes[index].position[0] = x; mVertexes[index].position[1] = y; mVertexes[index].position[2] = z; mVertexes[index].position[3] = w;&#125;void VertexBuffer::SetColor(size_t index, float r, float g, float b, float a)&#123; mVertexes[index].color[0] = r; mVertexes[index].color[1] = g; mVertexes[index].color[2] = b; mVertexes[index].color[3] = a;&#125;void VertexBuffer::SetNormal(size_t index, float x, float y, float z)&#123; mVertexes[index].normal[0] = x; mVertexes[index].normal[1] = y; mVertexes[index].normal[2] = z; mVertexes[index].normal[3] = 1.0f;&#125;void VertexBuffer::SetTexcoord(size_t index, float x, float y)&#123; mVertexes[index].texcoord[0] = x; mVertexes[index].texcoord[1] = y;&#125;void VertexBuffer::Bind()&#123; glBindBuffer(GL_ARRAY_BUFFER, mVbo); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(Vertex)*mVertexCount, mVertexes);&#125;void VertexBuffer::Unbind()&#123; glBindBuffer(GL_ARRAY_BUFFER, 0);&#125;Vertex&amp;VertexBuffer::Get(int index) &#123; return mVertexes[index];&#125; Shader类的功能主要是将GPU Program链接创建shader的步骤和传值给Shader的功能都封装了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Shader.h#pragma once#include \"GlobalGL.h\"#include \"utils.h\"#include \"VertexBuffer.h\"#include &lt;map&gt; #include &lt;stack&gt;using namespace std;struct UniformTexture&#123; GLuint mLocation; GLuint mTexture; UniformTexture() &#123; mLocation = -1; mTexture = 0; &#125;&#125;;struct UniformVec4&#123; GLuint mLocation; float v[4]; UniformVec4() &#123; mLocation = -1; memset(v, 0, sizeof(v)); &#125;&#125;;struct UniformMat&#123; GLuint mLocation; float *vPtr; UniformMat() &#123; mLocation = -1; vPtr = nullptr; &#125;&#125;;class Shader&#123; std::stack&lt;GLuint&gt; mAttachedShaders; std::map&lt;std::string, GLint&gt; mLocations;public: map&lt;string,UniformTexture*&gt; mTexures; map&lt;string, UniformVec4*&gt; mUniformVec4s; map&lt;string, UniformMat*&gt; mUniformMats; GLuint mProgram; Shader(); void Init(const char *vs, const char *fs); void Bind(); GLint DetectAttribute(const char *attributeName); GLint DetectUniform(const char *uniformName); void SetTextureWithPath(const char *name, const char *imagePath); void SetTexture(const char *name, GLuint texture); void SetUniformVec4(const char *name, float x,float y,float z, float w); void SetUniformMat(const char *name, float *matPtr); bool CheckDetected(const char *name); ~Shader();&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197//Shader.cpp#include \"Shader.h\"Shader::Shader()&#123;&#125;void Shader::Init(const char *vs, const char *fs)&#123; //初始化shader int nFileSize = 0; const char*vsCode = (char*)LoadFileContent(vs, nFileSize); const char*fsCode = (char*)LoadFileContent(fs, nFileSize); GLuint vsShader = CompileShader(GL_VERTEX_SHADER, vsCode); if (vsShader == 0) &#123; return; &#125; GLuint fsShader = CompileShader(GL_FRAGMENT_SHADER, fsCode); if (fsShader == 0) &#123; return; &#125; //gpu program 初始化 mProgram = CreateProgram(vsShader, fsShader); glDeleteShader(vsShader);//删除vsShader glDeleteShader(fsShader);//删除fsShader&#125;GLint Shader::DetectAttribute(const char* attributeName)&#123; GLint loc = glGetAttribLocation(mProgram, attributeName); if (loc != -1) &#123; mLocations.insert(std::pair&lt;std::string, GLint&gt;(attributeName, loc)); &#125; else &#123; printf(\"DetectAttribute Error! attributeName=%s\", attributeName); &#125; return loc;&#125;GLint Shader::DetectUniform(const char* uniformName)&#123; GLint loc = glGetUniformLocation(mProgram, uniformName); if (loc != -1) &#123; mLocations.insert(std::pair&lt;std::string, GLint&gt;(uniformName, loc)); &#125; else &#123; printf(\"DetectUniform Error! uniformName=%s\", uniformName); &#125; return loc;&#125;void Shader::Bind()&#123; //绑定当前GPU Program glUseProgram(mProgram); //设置纹理绑定，实现多个纹理的传输 int index = 0; for (auto iter = mTexures.begin(); iter != mTexures.end(); ++iter) &#123; glActiveTexture(GL_TEXTURE0 + index); glBindTexture(GL_TEXTURE_2D, iter-&gt;second-&gt;mTexture); glUniform1i(iter-&gt;second-&gt;mLocation, index ++); &#125; //传输设置过的uniform属性 for (auto iter = mUniformVec4s.begin();iter != mUniformVec4s.end();++iter) &#123; glUniform4fv(iter-&gt;second-&gt;mLocation, 1, iter-&gt;second-&gt;v); &#125; //设置uniform矩阵 for (auto iter = mUniformMats.begin(); iter != mUniformMats.end(); ++iter) &#123; glUniformMatrix4fv(iter-&gt;second-&gt;mLocation, 1, GL_FALSE, iter-&gt;second-&gt;vPtr); &#125; //设置attribute属性 if (CheckDetected(\"position\"))//检测是否需要用position &#123; glEnableVertexAttribArray(mLocations[\"position\"]); glVertexAttribPointer(mLocations[\"position\"], 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), 0); &#125; if (CheckDetected(\"color\"))//检测是否需要用color &#123; glEnableVertexAttribArray(mLocations[\"color\"]); glVertexAttribPointer(mLocations[\"color\"], 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(sizeof(float) * 4)); &#125; if (CheckDetected(\"texcoord\"))//检测是否需要用texcoord &#123; glEnableVertexAttribArray(mLocations[\"texcoord\"]); glVertexAttribPointer(mLocations[\"texcoord\"], 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(sizeof(float) * 8)); &#125; if (CheckDetected(\"normal\"))//检测是否需要用normal &#123; glEnableVertexAttribArray(mLocations[\"normal\"]); glVertexAttribPointer(mLocations[\"normal\"], 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(sizeof(float) * 12)); &#125;&#125;void Shader::SetTextureWithPath(const char *name, const char *imagePath)&#123; //创建一个图片 GLuint texture = CreateTexture2DFromBMP(imagePath); //设置图片 SetTexture(name, texture);&#125;void Shader::SetTexture(const char *name, GLuint texture)&#123; auto iter = mTexures.find(name); if (iter == mTexures.end())//如果图片没有设置过 &#123; GLint location = glGetUniformLocation(mProgram, name); if (location != -1) &#123; UniformTexture *t = new UniformTexture; t-&gt;mLocation = location; t-&gt;mTexture = texture; mTexures.insert(pair&lt;string, UniformTexture*&gt;(name, t)); &#125; &#125; else//图片已经设置过就替换该图 &#123; glDeleteTextures(1, &amp;iter-&gt;second-&gt;mTexture); iter-&gt;second-&gt;mTexture = texture; &#125;&#125;void Shader::SetUniformVec4(const char *name, float x, float y, float z, float w)&#123; auto iter = mUniformVec4s.find(name); if (iter == mUniformVec4s.end()) &#123; GLuint slot = DetectUniform(name); if (slot != -1) &#123; UniformVec4 *uVec4 = new UniformVec4; uVec4-&gt;mLocation = slot; uVec4-&gt;v[0] = x; uVec4-&gt;v[1] = y; uVec4-&gt;v[2] = z; uVec4-&gt;v[3] = w; mUniformVec4s.insert(pair&lt;string, UniformVec4*&gt;(name, uVec4)); &#125; &#125; else &#123; iter-&gt;second-&gt;v[0] = x; iter-&gt;second-&gt;v[1] = y; iter-&gt;second-&gt;v[2] = z; iter-&gt;second-&gt;v[3] = w; &#125;&#125;void Shader::SetUniformMat(const char *name, float *matPtr)&#123; auto iter = mUniformMats.find(name); if (iter == mUniformMats.end()) &#123; GLuint slot = DetectUniform(name); if (slot != -1) &#123; UniformMat *um = new UniformMat; um-&gt;mLocation = slot; um-&gt;vPtr = matPtr; mUniformMats.insert(pair&lt;string, UniformMat*&gt;(name, um)); &#125; &#125; else &#123; iter-&gt;second-&gt;vPtr = matPtr; &#125;&#125;bool Shader::CheckDetected(const char *name)&#123; auto iter = mLocations.find(name); return mLocations.end() != iter;&#125;Shader::~Shader()&#123;&#125; 有了这两个类的封装，实现绘制Sprite那就容易多了。 1234567891011121314//Sprite.h#pragma once#include \"VertexBuffer.h\"#include \"Shader.h\"class Sprite&#123; VertexBuffer *mVertexBuffer; Shader *mShader;public: Sprite(); ~Sprite(); void Init(const char *imgPath); void Draw();&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344//Sprite.cpp#include \"Sprite.h\"Sprite::Sprite()&#123;&#125;Sprite::~Sprite()&#123; delete mShader; delete mVertexBuffer;&#125;void Sprite::Init(const char *imgPath)&#123; //初始化顶点buffer 设置四个顶点的信息。 mVertexBuffer = new VertexBuffer; mVertexBuffer-&gt;SetSize(4); mVertexBuffer-&gt;SetPosition(0, -0.5f, -0.5f, -1.0f); mVertexBuffer-&gt;SetPosition(1, 0.5f, -0.5f, -1.0f); mVertexBuffer-&gt;SetPosition(2, 0.5f, 0.5f, -1.0f); mVertexBuffer-&gt;SetPosition(3, -0.5f, 0.5f, -1.0f); mVertexBuffer-&gt;SetTexcoord(0, 0.0f, 0.0f); mVertexBuffer-&gt;SetTexcoord(1, 1.0f, 0.0f); mVertexBuffer-&gt;SetTexcoord(2, 1.0f, 1.0f); mVertexBuffer-&gt;SetTexcoord(3, 0.0f, 1.0f); //初始化shader mShader = new Shader; mShader-&gt;Init(\"Res/Shader/first.vs\", \"Res/Shader/first.fs\"); mShader-&gt;SetTextureWithPath(\"U_Texture\", imgPath); mShader-&gt;DetectAttribute(\"position\"); mShader-&gt;DetectAttribute(\"texcoord\"); mShader-&gt;DetectUniform(\"U_Texture\");&#125;void Sprite::Draw()&#123; mVertexBuffer-&gt;Bind(); mShader-&gt;Bind(); glDrawArrays(GL_QUADS, 0, mVertexBuffer-&gt;mVertexCount); mVertexBuffer-&gt;Unbind();&#125; 经过抽象后，可能现在看起来总体实现的代码量多了，但是复用率提高了，对以后其他功能的实现提供便利。 新建DrawSpriteScene类，在初始化和帧绘制函数中创建和刷新这个Sprite。 123456789101112131415//DrawSpriteScene.h#pragma once#include \"BaseScene.h\"#include \"Sprite.h\"class DrawSpriteScene : public BaseScene&#123; Sprite *mSprite;public: DrawSpriteScene(); ~DrawSpriteScene(); void Init(); void Draw();&#125;; 12345678910111213141516171819202122232425262728//DrawSpriteScene.cpp#include \"DrawSpriteScene.h\"DrawSpriteScene::DrawSpriteScene()&#123;&#125;DrawSpriteScene::~DrawSpriteScene()&#123; delete mSprite;&#125;void DrawSpriteScene::Init()&#123; mSprite = new Sprite; mSprite-&gt;Init(\"Res/test.bmp\");&#125;void DrawSpriteScene::Draw()&#123; //清理背景颜色为黑色 glClearColor(0, 0, 0, 255); //清理颜色缓冲区和深度缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); mSprite-&gt;Draw();&#125; 在SceneManager类中切换该场景。 12345678//SceneManager.cpp#include \"DrawSpriteScene.h\"void SceneManager::EnterScene()&#123; mCurrentScene = new DrawSpriteScene(); mCurrentScene-&gt;Init();&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（十）attribute、uniform和varying的区别","slug":"（十）attribute、uniform和varying的区别","date":"2018-01-28T12:59:25.000Z","updated":"2018-04-14T13:35:38.281Z","comments":true,"path":"2018/01/28/（十）attribute、uniform和varying的区别/","link":"","permalink":"http://eamon.xyz/2018/01/28/（十）attribute、uniform和varying的区别/","excerpt":"","text":"初次接触这三种变量类型的时候肯定有点疑惑，特地为此小结一下。 1.attribute变量attribute变量是从shader外部传入的变量，只能在Vertex Shader中使用它。在不同的gl版本支持的attribute变量的数量是不一样的，attribute修饰符只能修饰float, vec2, vec3, vec4,mat2,mat3,mat4，attribute变量不能声明为数组或结构体。 如： 12345attribute vec4 position; //顶点坐标attribute vec3 normal; //顶点法线attribute vec2 texCoord; //顶点纹理坐标 传参过程： 通过glGetAttribLocation(）获取属性位置，使用glEnableVertexAttribArray()激活该位置，最后通过glVertexAttribPointer()指定fbo上的数据。 应用场景：传递顶点的位置、法线、颜色、纹理坐标。 2.uniform变量uniform变量也是从shader外部传入的变量，可以在Vertex Shader和Fragment Shader中使用它，它在shader中是只可以使用不能够去修改，在Vertex Shader和Fragment Shader中是共享的，相当于一个全局的变量。 123uniform mat4 viewMatrix; //视图矩阵uniform mat4 viewMatrix; //视图矩阵uniform vec3 lightPosition; //光源位置 传参过程： 通过glGetUniformLocation(）获取属性位置，最后通过glUniformxxx()传递参数。 应用场景：传递MVP矩阵、光照位置、颜色等全局参数。 3.varying变量varying变量是Vertex Shader向Fragment Shader传递的变量类型， 传参过程：可以在Vertex Shader中定义一个varying变量，然后赋值，在Fragment Shader中定义一个名称一样的varying变量就能接收到。 应用场景：纹理坐标、光照计算信息、法线等。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（九）使用Shader绘制三角形","slug":"（九）使用Shader绘制三角形","date":"2018-01-27T03:08:09.000Z","updated":"2018-04-14T14:43:05.401Z","comments":true,"path":"2018/01/27/（九）使用Shader绘制三角形/","link":"","permalink":"http://eamon.xyz/2018/01/27/（九）使用Shader绘制三角形/","excerpt":"","text":"学会用使用可编程管线绘制图形可以算是OpenGL入门的一个里程碑，是面向GPU编程的第一步。 在学习shader之前可以先大致看下OpenGL的渲染管线，在图中蓝色字部分就是可编程管线中三个重要的shader，其中Vertex Shader和Fragment Shader是最基础和硬件支持较为广泛的过程shader。 在之前的固定管线中，我们只需要调用gl的API设置绘制属性和传输绘制所需要的信息就能完成绘制，但这也限制了自由度。而在可编程管线中，我们可以选择自定义我们关心的可编程过程，实现自己想要的绘制效果。凡是都有两面性，提升了自由度，那必然会加大编程难度，先看下实现一个简单shader的几个基本步骤吧。 1.创建first.vs和first.fs shader文件。123456789101112//first.vsattribute vec4 position;//从外部传过来的顶点坐标attribute vec2 texcoord;//从外部传过来的纹理坐标varying vec2 V_Texcoord;//输出到片元的属性，顶点坐标void main()&#123; //gl_Position是用来传递顶点坐标的，这里先不做任何处理直接传值 gl_Position=vec4(position.x, position.y, position.z, 1.0); //赋值给varying变量，这个值可以在fs中获得到 V_Texcoord = texcoord;&#125; 1234567891011121314//first.fs//兼容OpenGL ES 定义数值精度为mediump#ifdef GL_ESprecision mediump float;#endifuniform sampler2D U_Texture;//从外部传过来的纹理采样器varying vec2 V_Texcoord; //接收vs传过来的值void main()&#123; //texture2D 内置函数 用于采样指定uv坐标下的纹理颜色 vec4 color = texture2D(U_Texture,V_Texcoord); //内置变量 设置最后该像素的颜色值 gl_FragColor= color;&#125; 2.加载first.vs和first.fs文件到内存。123int nFileSize = 0;const char* vsCode = (char*)LoadFileContent(\"Res/Shader/first.vs\", nFileSize);const char* fsCode = (char*)LoadFileContent(\"Res/Shader/first.fs\", nFileSize); 3.编译first.vs和first.fs shader。在utils文件中定义CompileShader方法，后续需要编译shader的时候直接调用即可。 123456789101112131415161718192021222324//utils.cppGLuint CompileShader(GLenum shaderType, const char *shaderCode)&#123; //创建一个shader GLuint shader = glCreateShader(shaderType); //设置这个shader的源代码 glShaderSource(shader, 1, &amp;shaderCode, nullptr); //编译shader glCompileShader(shader); //处理编译异常的信息 GLint result = GL_TRUE; //获取shader的编译时的状态 glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;result); if (result == GL_FALSE) &#123; char log[1024] = &#123; 0 &#125;; GLsizei logLen = 0; glGetShaderInfoLog(shader, 1024, &amp;logLen, log); printf(\"Compile shader fail error log：%s\\nshader code:\\n%s\\n\", log, shaderCode); glDeleteShader(shader); shader = 0; &#125; return shader;&#125; 12345678910//编译顶点着色器GLuint vsShader = CompileShader(GL_VERTEX_SHADER, vsCode);if (vsShader == 0) &#123; return;&#125;//编译片源着色器GLuint fsShader = CompileShader(GL_FRAGMENT_SHADER, fsCode);if (fsShader == 0) &#123; return;&#125; 4.创建一个GPU Program用来连接shader。同样地，在utils文件中定义CreateProgram方法。 123456789101112131415161718192021222324252627//utils.cppGLuint CreateProgram(GLuint vsShader, GLuint fsShader)&#123; //创建一个程序 GLuint program = glCreateProgram(); //设置顶点着色器 glAttachShader(program, vsShader); //设置片源着色器 glAttachShader(program, fsShader); //链接程序 glLinkProgram(program); //释放shader glDetachShader(program, vsShader); glDetachShader(program, fsShader); //检查gpu程序的链接状态 GLint result = GL_TRUE; glGetProgramiv(program, GL_LINK_STATUS, &amp;result); if (result == GL_FALSE) &#123; char log[1024] = &#123; 0 &#125;; GLsizei logLen = 0; glGetProgramInfoLog(program, 1024, &amp;logLen, log); printf(\"Create gpu program fail,link error : %s\\n\", log); program = 0; &#125; return program;&#125; 12345//创建gpu程序mGPUProgram = CreateProgram(vsShader, fsShader);//删除shaderglDeleteShader(vsShader);glDeleteShader(fsShader); 5.记录shader中的属性位置。观察vs和fs shader可以知道，我们需要为shader传递3个变量分别是attribute变量position和texcoord，以及uniform变量U_Texture。attribute和uniform以及varying关键字的差别后续再说，先了解attribute和uniform变量是如何传值的。 123mPositionLocation = glGetAttribLocation(mGPUProgram, \"position\");mTexcoordLocation = glGetAttribLocation(mGPUProgram, \"texcoord\");mTextureLocation = glGetUniformLocation(mGPUProgram, \"U_Texture\"); 这里需要引入一个插槽的概念来理解变量的传参过程，同一个GPU Program里面会为shader内部定义的attribute和uniform变量分别加上序号（从0开始自增）。不出意外的话属性position获取到的编号应该是0，texcoord获取到的是1，而uniform编号是不会和attribute的相互干扰的，所以U_Texture获取到的编号是0。 6.绘制的时候启用Program，根据记录的shader属性位置传入shader需要的属性信息。1234567891011121314151617181920212223242526272829//绑定vboglBindBuffer(GL_ARRAY_BUFFER, mVBO);//绑定ProgramglUseProgram(mGPUProgram);//绑定纹理glBindTexture(GL_TEXTURE_2D, mTexture);//激活该纹理glActiveTexture(mTexture);//传递uniform属性，#1属性插槽位置，#2纹理索引glUniform1f(mTextureLocation, mTexture);//给attribute变量传值时需要先激活该槽位，再通过指针指定vbo上的数据为其赋值//激活position这个属性槽位glEnableVertexAttribArray(mPositionLocation);glVertexAttribPointer(mPositionLocation,//需要赋值的槽位 3,//每个顶点有几个float变量 GL_FLOAT,//数值类型为float GL_FALSE,//不需要归一化float值，GL_TRUE指的数据会变换到（0-1） sizeof(float) * 5, //每个顶点间的偏移量 0);//起始变量的地址//激活texcoord这个属性槽位glEnableVertexAttribArray(mTexcoordLocation);glVertexAttribPointer(mTexcoordLocation, //需要赋值的槽位 2,//每个顶点有几个float变量 GL_FLOAT,//数值类型为float GL_FALSE,//不需要归一化float值，GL_TRUE指的数据会变换到（0-1） sizeof(float) * 5,//每个顶点间的偏移量 (void*)(sizeof(float) * 3));//起始变量的地址 完整代码实现如下： 123456789101112131415161718//FirstShaderScene.h#pragma once#include \"BaseScene.h\"class FirstShaderScene : public BaseScene&#123; GLuint mVBO; GLuint mTexture; GLuint mGPUProgram; GLuint mPositionLocation; GLuint mTexcoordLocation; GLuint mTextureLocation;public: FirstShaderScene(); ~FirstShaderScene(); void Init(); void Draw();&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//FirstShaderScene.cpp#include \"FirstShaderScene.h\"FirstShaderScene::FirstShaderScene()&#123;&#125;FirstShaderScene::~FirstShaderScene()&#123;&#125;void FirstShaderScene::Init()&#123; //顶点数据左侧顶点的三个是坐标，右侧是对应的纹理坐标 float data[] = &#123; -0.5f, -0.5f, -1.0f, 0.0f,0.0f, 0.5f, -0.5f, -1.0f, 1.0f,0.0f, 0.0f, 0.5f, -1.0f, 0.5f,1.0f &#125;; //创建一个vbo glGenBuffers(1, &amp;mVBO); //绑定vbo glBindBuffer(GL_ARRAY_BUFFER, mVBO); //上传数据到GPU glBufferData(GL_ARRAY_BUFFER, //顶点buffer sizeof(data), //数据的大小 data, //数据数组 GL_STATIC_DRAW); //绘制类型，不需要更改用静态就可以 //取消绑定vbo glBindBuffer(GL_ARRAY_BUFFER, 0); //初始化一张纹理 mTexture = CreateTexture2DFromBMP(\"Res/test.bmp\"); //读取shader的源代码 int nFileSize = 0; const char* vsCode = (char*)LoadFileContent(\"Res/Shader/first.vs\", nFileSize); const char* fsCode = (char*)LoadFileContent(\"Res/Shader/first.fs\", nFileSize); //编译顶点着色器 GLuint vsShader = CompileShader(GL_VERTEX_SHADER, vsCode); if (vsShader == 0) &#123; return; &#125; //编译片源着色器 GLuint fsShader = CompileShader(GL_FRAGMENT_SHADER, fsCode); if (fsShader == 0) &#123; return; &#125; //创建gpu程序 mGPUProgram = CreateProgram(vsShader, fsShader); //删除shader glDeleteShader(vsShader); glDeleteShader(fsShader); mPositionLocation = glGetAttribLocation(mGPUProgram, \"position\"); mTexcoordLocation = glGetAttribLocation(mGPUProgram, \"texcoord\"); mTextureLocation = glGetUniformLocation(mGPUProgram, \"U_Texture\");&#125;void FirstShaderScene::Draw()&#123; //清理背景颜色为黑色 glClearColor(0, 0, 0, 255); //清理颜色缓冲区和深度缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //开启纹理 glEnable(GL_TEXTURE_2D); //绑定vbo glBindBuffer(GL_ARRAY_BUFFER, mVBO); //绑定Program glUseProgram(mGPUProgram); //绑定纹理 glBindTexture(GL_TEXTURE_2D, mTexture); //激活该纹理 glActiveTexture(mTexture); //传递uniform属性，#1属性插槽位置，#2纹理索引 glUniform1f(mTextureLocation, mTexture); //给attribute变量传值时需要先激活该槽位，再通过指针指定vbo上的数据为其赋值 //激活position这个属性槽位 glEnableVertexAttribArray(mPositionLocation); glVertexAttribPointer(mPositionLocation,//需要赋值的槽位 3,//每个顶点有几个float变量 GL_FLOAT,//数值类型为float GL_FALSE,//不需要归一化float值，GL_TRUE指的数据会变换到（0-1） sizeof(float) * 5, //每个顶点间的偏移量 0);//起始变量的地址 //激活texcoord这个属性槽位 glEnableVertexAttribArray(mTexcoordLocation); glVertexAttribPointer(mTexcoordLocation, //需要赋值的槽位 2,//每个顶点有几个float变量 GL_FLOAT,//数值类型为float GL_FALSE,//不需要归一化float值，GL_TRUE指的数据会变换到（0-1） sizeof(float) * 5,//每个顶点间的偏移量 (void*)(sizeof(float) * 3));//起始变量的地址 //绑定vbo glBindBuffer(GL_ARRAY_BUFFER, 0); //绘制一个三角形,起始顶点为0,绘制3个顶点 glDrawArrays(GL_TRIANGLES, 0, 3); //取消vbo的绑定 glBindBuffer(GL_ARRAY_BUFFER, 0); //解除纹理绑定 glBindTexture(GL_TEXTURE_2D, 0);&#125; 在SceneManager.cpp中修改跳转场景为FirstShaderScene 12345678//SceneManager.cpp#include \"FirstShaderScene.h\"void SceneManager::EnterScene()&#123; mCurrentScene = new FirstShaderScene(); mCurrentScene-&gt;Init();&#125; 为了能及时发现错误，可以通过设置工程配置将控制台显示出来，以便方便观察异常输出。【属性】–&gt;【生成事件】–&gt;【生成后事件】，在【命令行】中填入editbin /SUBSYSTEM:CONSOLE $(OutDir)$(ProjectName).exe即可。 没错，要是实现没问题的话，还是暗中观察。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（八）使用VBO绘制三角形","slug":"（八）使用VBO绘制三角形","date":"2018-01-20T16:21:12.000Z","updated":"2018-04-14T06:48:44.701Z","comments":true,"path":"2018/01/21/（八）使用VBO绘制三角形/","link":"","permalink":"http://eamon.xyz/2018/01/21/（八）使用VBO绘制三角形/","excerpt":"","text":"在绘制第一个三角形之后发现一个问题，每次调用Draw函数的时候，CPU都会向GPU传输顶点坐标、纹理坐标、颜色等信息。在不改变的三角形的数据的前提下，这些传输开销都是在浪费性能。好在OpenGL在2.1版本之后用一个新特性可以避免这种无畏的开销，它就是VBO（Vertex buffer object）。 VBO的工作原理是可以选择预先将绘制所需要的信息，用数组的方式先上传到显存中，在绘制的时候通过绑定VBO来指定绘制所需要的数据的偏移指针的方式来绘制。 创建这次的场景类VBOTriangleScene继承之前制作的场景基类BaseScene。 1234567891011121314//VBOTriangleScene.h#pragma once#include \"BaseScene.h\"class VBOTriangleScene : public BaseScene&#123; GLuint mVBO; GLuint mTexture;public: VBOTriangleScene(); ~VBOTriangleScene(); void Init(); void Draw();&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//VBOTriangleScene.cpp#include \"VBOTriangleScene.h\"VBOTriangleScene::VBOTriangleScene()&#123;&#125;VBOTriangleScene::~VBOTriangleScene()&#123;&#125;void VBOTriangleScene::Init()&#123; //顶点数据左侧顶点的三个是坐标，右侧是对应的纹理坐标 float data[] = &#123; -0.5f, -0.5f, -1.0f, 0.0f,0.0f, 0.5f, -0.5f, -1.0f, 1.0f,0.0f, 0.0f, 0.5f, -1.0f, 0.5f,1.0f &#125;; //创建一个vbo glGenBuffers(1, &amp;mVBO); //绑定vbo glBindBuffer(GL_ARRAY_BUFFER, mVBO); //上传数据到GPU glBufferData(GL_ARRAY_BUFFER, //顶点buffer sizeof(data), //数据的大小 data, //数据数组 GL_STATIC_DRAW); //绘制类型，不需要更改用静态就可以 //取消绑定vbo glBindBuffer(GL_ARRAY_BUFFER, 0); //初始化一张纹理 mTexture = CreateTexture2DFromBMP(\"Res/test.bmp\");&#125;void VBOTriangleScene::Draw()&#123; //清理背景颜色为黑色 glClearColor(0, 0, 0, 255); //清理颜色缓冲区和深度缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //开启纹理 glEnable(GL_TEXTURE_2D); //绑定纹理 glBindTexture(GL_TEXTURE_2D, mTexture); //绑定vbo glBindBuffer(GL_ARRAY_BUFFER, mVBO); //开启客户端状态 glEnableClientState(GL_VERTEX_ARRAY);//顶点数组 glEnableClientState(GL_TEXTURE_COORD_ARRAY);//纹理坐标 //指定顶点指针 glVertexPointer(3, //一个点有三个数据 GL_FLOAT, //每个数据都是float类型 sizeof(GL_FLOAT) * 5, //两个顶点之间的偏移量 0); //顶点的起始地址，0表示数组的首位 //指定纹理坐标指针，注意观察纹理坐标在data数组中的位置 glTexCoordPointer(2, //一个点有两个数据 GL_FLOAT, //每个数据都是float类型 sizeof(GL_FLOAT) * 5, //两个顶点之间的偏移量 (void*)(sizeof(GL_FLOAT) * 3));//顶点的起始地址，需要跳过3个顶点坐标 //绘制一个三角形,起始顶点为0,绘制3个顶点 glDrawArrays(GL_TRIANGLES, 0, 3); //取消vbo的绑定 glBindBuffer(GL_ARRAY_BUFFER, 0); //解除纹理绑定 glBindTexture(GL_TEXTURE_2D, 0); //禁用客户端状态 glDisableClientState(GL_VERTEX_ARRAY); glDisableClientState(GL_TEXTURE_COORD_ARRAY);&#125; 123456#include \"VBOTriangleScene.h\"void SceneManager::EnterScene()&#123; mCurrentScene = new VBOTriangleScene(); mCurrentScene-&gt;Init();&#125; glVertexPointer和glTexCoordPointer这两个函数理解起来可能有点费劲，主要作用是指定当前绑定的VBO中的数据的偏移量指针，理解这两个函数的使用对后续学习有很大的帮助。最后的运行结果应该是跟之前的三角形是一样的。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"(七)抽象出场景管理器","slug":"（七）抽象出场景管理器","date":"2018-01-20T12:28:53.000Z","updated":"2018-04-14T05:17:20.476Z","comments":true,"path":"2018/01/20/（七）抽象出场景管理器/","link":"","permalink":"http://eamon.xyz/2018/01/20/（七）抽象出场景管理器/","excerpt":"","text":"为了方便做代码展示和遵循开闭原则，将之前的代码做一些封装。实现一个场景管理类和场景基类，新展示的代码可以继承场景基类，然后在场景管理器内做切换就可以了。 新建一个BaseScene类作为场景的基类，定义两个抽象方法，Init()和Draw()，具体实现交给派生类。 123456789101112//BaseScene.h#pragma once#include \"Utils.h\"class BaseScene&#123;public: BaseScene(); virtual ~BaseScene(); virtual void Init() = 0; virtual void Draw() = 0;&#125;; 12345678910//BaseScene.cpp#include \"BaseScene.h\"BaseScene::BaseScene()&#123;&#125;BaseScene::~BaseScene()&#123;&#125; 新建一个TriangleScene类派生于BaseScene类，将main.cpp里的Init()和Draw()提取出来在场景类中实现。 12345678910111213//TriangleScene.h#pragma once#include \"BaseScene.h\"class TriangleScene : public BaseScene&#123; GLuint texture; //记录三角形贴图的索引public: TriangleScene(); ~TriangleScene(); void Init(); void Draw();&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344//TriangleScene.cpp#include \"TriangleScene.h\"TriangleScene::TriangleScene()&#123;&#125;TriangleScene::~TriangleScene()&#123;&#125;void TriangleScene::Init()&#123; texture = CreateTexture2DFromBMP(\"Res/test.bmp\");&#125;void TriangleScene::Draw()&#123; //清理背景颜色为黑色 glClearColor(0, 0, 0, 255); //清理颜色缓冲区和深度缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //开启纹理 glEnable(GL_TEXTURE_2D); //绑定纹理 glBindTexture(GL_TEXTURE_2D, texture); //绘制三角形的指令 glBegin(GL_TRIANGLES); //顶点按逆时针的方式输入 //glColor4ub(255, 0, 0, 255); glTexCoord2f(0.0f, 0.0f);//绑定纹理坐标为左下角 glVertex3f(-0.5f, -0.5f, -1.0f); //第一个顶点 原点左下角 //glColor4ub(0, 255, 0, 255); glTexCoord2f(1.0f, 0.0f);//绑定纹理坐标为右下角 glVertex3f(0.5f, -0.5f, -1.0f); //第二个顶点 原点右下角 //glColor4ub(0, 0, 255, 255); glTexCoord2f(0.5f, 1.0f);//绑定纹理坐标为中间顶部 glVertex3f(0.0f, 0.5f, -1.0f); //第三个顶点 原点正上方 glEnd(); //解除纹理绑定 glBindTexture(GL_TEXTURE_2D, 0);&#125; 新建一个SceneManager类，用来设置当前场景及初始化和绘制当前场景，并且实现单例在main.cpp中调用。 1234567891011121314//SceneManager.h#pragma once#include \"BaseScene.h\"class SceneManager&#123;private: BaseScene *mCurrentScene;//当前运行的场景 SceneManager();public: static SceneManager* GetInstance();//场景管理类的实例 ~SceneManager(); void EnterScene(); void Draw();&#125;; 1234567891011121314151617181920212223242526272829303132//SceneManager.cpp#include \"SceneManager.h\"#include \"TriangleScene.h\"static SceneManager *mInstance = nullptr;//管理器唯一对象SceneManager::SceneManager()&#123;&#125;SceneManager* SceneManager::GetInstance()&#123; if (mInstance == nullptr) &#123; mInstance = new SceneManager(); &#125; return mInstance;&#125;SceneManager::~SceneManager()&#123;&#125;void SceneManager::EnterScene()&#123; mCurrentScene = new TriangleScene(); mCurrentScene-&gt;Init();&#125;void SceneManager::Draw()&#123; mCurrentScene-&gt;Draw();&#125; 在main.cpp中的Init()和Draw()方法中调用场景管理器相应的方法。 1234567891011//main.cpp#include \"SceneManager.h\"void Init()&#123; SceneManager::GetInstance()-&gt;EnterScene();&#125;void Draw()&#123; SceneManager::GetInstance()-&gt;Draw();&#125; 最后运行的结果应该是跟上一章一样的。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（六）为三角形贴图","slug":"（六）为三角形贴图","date":"2018-01-07T07:02:58.000Z","updated":"2018-03-25T12:36:45.748Z","comments":true,"path":"2018/01/07/（六）为三角形贴图/","link":"","permalink":"http://eamon.xyz/2018/01/07/（六）为三角形贴图/","excerpt":"","text":"创建GLTexture需要在Utils.h和Utils.cpp中声明和定义一个获取创建GL纹理的函数CreateTexture2D。 123456//Utils.h#pragma once#include \"GlobalGL.h\"GLuint CreateTexture2D(unsigned char* pixelData, int width, int height, GLenum type); 12345678910111213141516171819202122232425262728//Utils.cppGLuint CreateTexture2D(unsigned char* pixelData, int width, int height, GLenum type)&#123; GLuint texture = 0;//纹理索引 glGenTextures(1, &amp;texture);//在gl环境中生成一个纹理索引 glBindTexture(GL_TEXTURE_2D, texture);//绑定该纹理索引 //设置如何把纹理象素映射成像素 //放大过滤设置，使用线性过滤 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); //缩小过滤设置，使用线性过滤 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); //S方向上的贴图模式，clamp是指超出(0,1.0)范围用边界补充 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); //T方向上的贴图模式，clamp是指超出(0,1.0)范围用边界补充 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); //根据参数生成一张2d纹理 glTexImage2D(GL_TEXTURE_2D,//纹理类型 0, //level 执行细节级别 type,//指定纹理中的颜色组件。常见有GL_ALPHA,GL_RGB,GL_RGBA等 width, height,//纹理宽高 0,//指定边界宽度 type,// 像素数据的颜色格式 GL_UNSIGNED_BYTE, //指定像素数据的数据类型 pixelData);//指定内存中指向图像数据的指针 glBindTexture(GL_TEXTURE_2D, 0);//解除对贴图的绑定 return texture;&#125; 在Utils.h和Utils.cpp中声明和定义一个可以直接通过BMP文件路径就能创建GL纹理的函数，这样之后想要创建一张图片只需要调用这个函数。 123456//Utils.h#pragma once#include \"GlobalGL.h\"GLuint CreateTexture2DFromBMP(const char* path); 123456789101112131415161718192021//Utils.cppGLuint CreateTexture2DFromBMP(const char* path)&#123; int nFileSize = 0; unsigned char* bmpFileContent = LoadFileContent(path, nFileSize); if (bmpFileContent == nullptr) &#123; return 0; &#125; int bmpWidth = 0, bmpHeight = 0; unsigned char* pixelData = DecodeBMP(bmpFileContent, bmpWidth, bmpHeight); if (bmpWidth == 0) &#123; delete bmpFileContent; return 0; &#125; GLuint texture = CreateTexture2D(pixelData, bmpWidth, bmpHeight, GL_RGB); delete bmpFileContent; return texture;&#125; 为三角形绑定贴图在main.cpp中定义一个全局变量GLuint textue用来记录纹理的索引值，然后在Init()函数中创建一张纹理并保存。 1234567891011121314151617181920212223242526272829303132333435//main.cppGLuint textue;//记录纹理索引void Init()&#123; textue = CreateTexture2DFromBMP(\"Res/test.bmp\");&#125;void Draw()&#123; //清理颜色缓冲区和深度缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清理背景颜色为黑色 glClearColor(0, 0, 0, 255); //开启纹理 glEnable(GL_TEXTURE_2D); //绑定纹理 glBindTexture(GL_TEXTURE_2D, textue); //绘制三角形的指令 glBegin(GL_TRIANGLES); //顶点按逆时针的方式输入 //glColor4ub(255, 0, 0, 255); glTexCoord2f(0.0f, 0.0f);//绑定纹理坐标为左下角 glVertex3f(-0.5f, -0.5f, -1.0f); //第一个顶点 原点左下角 //glColor4ub(0, 255, 0, 255); glTexCoord2f(1.0f, 0.0f);//绑定纹理坐标为右下角 glVertex3f(0.5f, -0.5f, -1.0f); //第二个顶点 原点右下角 //glColor4ub(0, 0, 255, 255); glTexCoord2f(0.5f, 1.0f);//绑定纹理坐标为中间顶部 glVertex3f(0.0f, 0.5f, -1.0f); //第三个顶点 原点正上方 glEnd(); //解除纹理绑定 glBindTexture(GL_TEXTURE_2D, 0);&#125; 注意：设置顶点颜色和纹理坐标都是要在设置顶点坐标之前，不然会认为是设置在下一个顶点里面。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（五）解析BMP文件","slug":"（五）解析BMP文件","date":"2018-01-07T05:02:58.000Z","updated":"2018-03-25T12:18:17.814Z","comments":true,"path":"2018/01/07/（五）解析BMP文件/","link":"","permalink":"http://eamon.xyz/2018/01/07/（五）解析BMP文件/","excerpt":"","text":"BMP文件是Windows操作系统中的标准图像文件格式，它采用位映射存储格式，除了图像深度可选以外，不采用其他任何压缩，所以解析BMP文件也比较简单。 图像文件头 1）1-2：(这里的数字代表的是字节，下同）图像文件头。0x4d42=’BM’，表示是Windows支持的BMP格式。(注意：查ascii表B 0x42,M0x4d,bfType 为两个字节，B为low字节，M为high字节所以bfType=0x4D42，而不是0x424D，请注意) 2）3-6：整个文件大小。4690 0000，为00009046h=36934。 3）7-8：保留，必须设置为0。 4）9-10：保留，必须设置为0。 5）11-14：从文件开始到位图数据之间的偏移量(14+40+4*（2^biBitCount）)(在有颜色板的情况下)。4600 0000，为00000046h=70，上面的文件头就是35字=70字节。 位图信息头 6）15-18：位图图信息头长度。 7) 19-22：位图宽度，以像素为单位。8000 0000，为00000080h=128。 8）23-26：位图高度，以像素为单位。9000 0000，为00000090h=144。 9）27-28：位图的位面数，该值总是1。0100，为0001h=1。 10）29-30：每个像素的位数。有1（单色），4（16色），8（256色），16（64K色，高彩色），24（16M色，真彩色），32（4096M色，增强型真彩色）。1000为0010h=16。 在Utils.h文件中声明DecodeBMP函数，并在Utils.cpp文件中定义。 12//Utils.hunsigned char* DecodeBMP(unsigned char* bmpFileData, int&amp; width, int&amp; height); 123456789101112131415161718192021222324252627//Utils.cppunsigned char* DecodeBMP(unsigned char* bmpFileData, int&amp; width, int&amp; height)&#123; //用记事本打开bmp图片可以看到文件首部会有BMP字符表示 //0x4D42正是BM的ASCII码 0x4D42 ='BM' //unsigned short 为两个字节大小 //取该地址的内容就是两个字节 if (0x4D42 == *((unsigned short*)bmpFileData)) &#123; //文件头第十个字节处可以获取到像素相对于文件首地址的偏移量 int pixelDataOffset = *((int*)(bmpFileData + 10)); width = *((int*)(bmpFileData + 18)); height = *((int*)(bmpFileData + 22)); //算出像素信息开始的地址 unsigned char* pixelData = bmpFileData + pixelDataOffset; for (int i = 0; i &lt; width * height * 3; i += 3) &#123; //格式从BGR转换成RGB unsigned char temp = pixelData[i]; pixelData[i] = pixelData[i + 2]; pixelData[i + 2] = temp; &#125; return pixelData; &#125; return nullptr;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（四）实现文件加载","slug":"（四）实现文件加载","date":"2018-01-07T02:29:55.000Z","updated":"2018-03-25T12:31:00.384Z","comments":true,"path":"2018/01/07/（四）实现文件加载/","link":"","permalink":"http://eamon.xyz/2018/01/07/（四）实现文件加载/","excerpt":"","text":"要使用纹理、模型、shader等文件的前提条件是将这些资源从磁盘加载到内存中，本文实现将资源通过字节的形式加载到内存。 在实现加载代码之前先整理下gl头文件的引用，创建一个头文件GlobalGL.h。 12345678//GlobalGL.h#pragma once#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include \"glew.h\"#include &lt;gl/GL.h&gt;#include &lt;gl/GLU.h&gt;#include &lt;gl/glext.h&gt; 12//main.cpp#include \"GlobalGL.h\" 新建Utils.h和Utils.cpp文件。 12345//Utils.h#pragma once#include \"GlobalGL.h\"unsigned char* LoadFileContent(const char* path, int &amp;fileSize); 1234567891011121314151617181920212223242526//Utils.cpp#include \"Utils.h\"unsigned char* LoadFileContent(const char* path, int &amp;fileSize)&#123; unsigned char* fileContent = nullptr; fileSize = 0; FILE* pFile = fopen(path, \"rb\");//read byte if (pFile) &#123; fseek(pFile, 0, SEEK_END);//文件指针移动到文件尾部 int nLen = ftell(pFile); //求得当前指针距离首部偏移量 if (nLen &gt; 0) &#123; rewind(pFile);//回到首部位置 fileContent = new unsigned char[nLen + 1]; //读取文件的内容 fread(fileContent, sizeof(unsigned char), nLen, pFile); fileContent[nLen] = '\\0'; fileSize = nLen; &#125; fclose(pFile); &#125; return fileContent;&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（三）基本图元的介绍","slug":"（三）基本图元的介绍","date":"2018-01-06T03:02:00.000Z","updated":"2018-03-25T12:18:03.852Z","comments":true,"path":"2018/01/06/（三）基本图元的介绍/","link":"","permalink":"http://eamon.xyz/2018/01/06/（三）基本图元的介绍/","excerpt":"","text":"OpenGL提供了多种图元的绘制，其中最为重要的图元是GL_TRIANGLES和GL_QUADS，其他使用的频率不高的图元在用的时候查下资料就可以了。 GL_POINTS：把每一个顶点作为一个点进行处理，顶点n即定义了点n，共绘制N个点 GL_LINES：把每一个顶点作为一个独立的线段，顶点2n－1和2n之间共定义了n条线段，总共绘制N/2条线段 GL_LINE_STRIP：绘制从第一个顶点到最后一个顶点依次相连的一组线段，第n和n+1个顶点定义了线段n，总共绘制n－1条线段 L_LINE_LOOP：绘制从第一个顶点到最后一个顶点依次相连的一组线段，然后最后一个顶点和第一个顶点相连，第n和n+1个顶点定义了线段n，总共绘制n条线段 GL_TRIANGLES：把每个顶点作为一个独立的三角形，顶点3n－2、3n－1和3n定义了第n个三角形，总共绘制N/3个三角形 GL_TRIANGLE_STRIP：绘制一组相连的三角形，对于奇数n，顶点n、n+1和n+2定义了第n个三角形；对于偶数n，顶点n+1、n和n+2定义了第n个三角形，总共绘制N-2个三角形 GL_TRIANGLE_FAN：绘制一组相连的三角形，三角形是由第一个顶点及其后给定的顶点确定，顶点1、n+1和n+2定义了第n个三角形，总共绘制N-2个三角形 GL_QUADS：绘制由四个顶点组成的一组单独的四边形。顶点4n－3、4n－2、4n－1和4n定义了第n个四边形。总共绘制N/4个四边形 GL_QUAD_STRIP：绘制一组相连的四边形。每个四边形是由一对顶点及其后给定的一对顶点共同确定的。顶点2n－1、2n、2n+2和2n+1定义了第n个四边形，总共绘制N/2-1个四边形 GL_POLYGON：绘制一个凸多边形。顶点1到n定义了这个多边形。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（二）绘制第一个三角形","slug":"（二）绘制第一个三角形","date":"2018-01-06T02:33:14.000Z","updated":"2018-03-25T12:31:36.826Z","comments":true,"path":"2018/01/06/（二）绘制第一个三角形/","link":"","permalink":"http://eamon.xyz/2018/01/06/（二）绘制第一个三角形/","excerpt":"","text":"在搭建好OpenGL环境前提下使用glBegin()和glEnd()绘制一个三角形，实现main.cpp文件中的Draw()方法。 1234567891011121314void Draw()&#123; //清理颜色缓冲区和深度缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清理背景颜色为黑色 glClearColor(0, 0, 0, 255); //绘制三角形的指令 glBegin(GL_TRIANGLES); //顶点按逆时针的方式输入 glVertex3f(-0.5f, -0.5f, -1.0f); //第一个顶点 原点左下角 glVertex3f(0.5f, -0.5f, -1.0f); //第二个顶点 原点右下角 glVertex3f(0.0f, 0.5f, -1.0f); //第三个顶点 原点正上方 glEnd();&#125; 输出结果应该是一个白色的三角形，接下来给这三个顶点都设置成红绿蓝三种颜色。 glColor4ub()方法能为顶点设置颜色，因为GL是状态切换的机制，所以在为顶点颜色赋值的过程好比一直在切换画笔。 123456789101112131415161718void Draw()&#123; //清理颜色缓冲区和深度缓冲区 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清理背景颜色为黑色 glClearColor(0, 0, 0, 255); //绘制三角形的指令 glBegin(GL_TRIANGLES); //顶点按逆时针的方式输入 glColor4ub(255, 0, 0, 255); glVertex3f(-0.5f, -0.5f, -1.0f); //第一个顶点 原点左下角 glColor4ub(0, 255, 0, 255); glVertex3f(0.5f, -0.5f, -1.0f); //第二个顶点 原点右下角 glColor4ub(0, 0, 255, 255); glVertex3f(0.0f, 0.5f, -1.0f); //第三个顶点 原点正上方 glEnd();&#125;","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]},{"title":"（一）OpenGL环境搭建","slug":"（一）OpenGL环境搭建","date":"2018-01-05T12:59:25.000Z","updated":"2018-03-25T12:17:44.313Z","comments":true,"path":"2018/01/05/（一）OpenGL环境搭建/","link":"","permalink":"http://eamon.xyz/2018/01/05/（一）OpenGL环境搭建/","excerpt":"","text":"创建项目使用Visual Studio创建一个win32空项目，若使用2017版本则可以选择Windows桌面向导来创建一个空的win32项目。 初始化窗体创建一个main.cpp，为程序添加入口函数。 12345678910#include &lt;windows.h&gt;int WinMain(_In_ HINSTANCE hInstance,//当前实例的句柄 _In_opt_ HINSTANCE hPrevInstance,//前一个实例的句柄 _In_ LPSTR lpCmdLine,//命令行参数 _In_ int nShowCmd)//窗体显示形式(最大化、最小化)&#123; system(\"pause\"); return 0;&#125; 如果没什么问题的话，运行起来可以看到一个黑色窗体。接下进行窗体类的初始化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;windows.h&gt;#include &lt;stdio.h&gt;LRESULT CALLBACK GLWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123; switch (msg) &#123; case WM_DESTROY: exit(0); &#125; return DefWindowProc(hwnd, msg, wParam, lParam);&#125;void Init()&#123; //初始化一些gl变量&#125;void Draw()&#123; //绘制gl的函数&#125;void InitGLEnv(HDC &amp;dc)&#123; //初始化gl环境&#125;int WinMain(_In_ HINSTANCE hInstance,//当前实例的句柄 _In_opt_ HINSTANCE hPrevInstance,//前一个实例的句柄 _In_ LPSTR lpCmdLine,//命令行参数 _In_ int nShowCmd)//窗体显示形式(最大化、最小化)&#123; WNDCLASSEX wndclass; wndclass.cbClsExtra = 0;//窗口类型的额外空间 wndclass.cbSize = sizeof(WNDCLASSEX);//这个对象实际占的内存 wndclass.cbWndExtra = 0;//窗口的额外内存 wndclass.hbrBackground = NULL;//使用GL背景擦除，设置为NULL就可以了 wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); //设置一个箭头作为光标 wndclass.hIcon = NULL;//应用程序在磁盘的图标 wndclass.hIconSm = NULL;//应用程序运行时显示在左上角的图标 wndclass.hInstance = hInstance;//应用程序的实例 wndclass.lpfnWndProc = GLWindowProc;//窗口消息调用函数 wndclass.lpszClassName = L\"GL Window\";//注册窗口使用的名称 wndclass.lpszMenuName = NULL;//菜单名称 wndclass.style = CS_VREDRAW | CS_HREDRAW;//重绘的方式，使用垂直和水平重绘 //注册窗口 ATOM atom = RegisterClassEx(&amp;wndclass); if (!atom) &#123; MessageBox(NULL, L\"Notice\", L\"Error\", MB_OK); return 0; &#125; //计算屏幕加上边框的Rect值是多少 RECT rect; rect.left = 0; rect.right = 800; rect.top = 0; rect.bottom = 600; AdjustWindowRect(&amp;rect, WS_OVERLAPPEDWINDOW, NULL); int wWidth = rect.right - rect.left; int wHeight = rect.bottom - rect.top; //创建窗口类 HWND hwnd = CreateWindowEx(NULL,//窗口的额外风格 L\"GL Window\",//注册的窗口名称 需要跟上面结构体注册的名称一致 L\"OpenGL Window\",//显示在窗口上的title内容 WS_OVERLAPPEDWINDOW,//窗体的风格 100, 100, wWidth, wHeight,//窗口的Rect NULL,//父窗口的句柄 NULL,//菜单的句柄 hInstance,//应用程序的实例 NULL);//额外的参数 可能会传WM_QUIT消息 可以不需要 //初始化gl环境 InitGLEnv(dc); //显示窗口 ShowWindow(hwnd, SW_SHOW); //更新窗口 UpdateWindow(hwnd); //初始化 Init(); //处理消息循环 MSG msg; while (true) &#123; //实时获取消息队列里的消息，并抛出去 if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) &#123; if (msg.message == WM_CLOSE) &#123; printf(\"结束\"); break; &#125; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; //执行绘制 Draw(); //交换缓冲池 SwapBuffers(dc); &#125; return 0;&#125; 现在应该可以看到一个白色的自定义的窗口，而不是一开始那个黑色控制台。但这些跟OpenGL还没什么关系，那么接下来我们继续完善代码，初始化好GL的环境。 初始化OpenL环境首先在main.cpp文件的首部添加GL的依赖库和头文件。 123456789101112131415161718192021222324252627#include &lt;gl/GL.h&gt;#include &lt;gl/GLU.h&gt;#include &lt;gl/glext.h&gt;#include \"glew.h\"#pragma comment(lib,\"opengl32.lib\") //vs自带#pragma comment(lib,\"glew32.lib\")void InitGLEnv(HDC &amp;dc)&#123; PIXELFORMATDESCRIPTOR pfd; //像素格式描述对象 memset(&amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR)); //初始化对象内存 pfd.nVersion = 1;//直接写1就好 pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);//该结构体占用多大内存 pfd.cColorBits = 32;//颜色值位数 pfd.cDepthBits = 24;//深度值位数 pfd.cStencilBits = 8;//蒙版值位数 pfd.iPixelType = PFD_TYPE_RGBA;//像素类型为RGBA pfd.dwFlags = PFD_DRAW_TO_WINDOW//绘制的窗口 | PFD_SUPPORT_OPENGL//支持OpenGL | PFD_DOUBLEBUFFER; //双缓冲区 //选择符合要求的像素格式,并且把其他参数设置完整 int pixelFormat = ChoosePixelFormat(dc, &amp;pfd); SetPixelFormat(dc, pixelFormat, &amp;pfd);//设置像素格式 HGLRC rc = wglCreateContext(dc);//图形操作描述表。OpenGL Render Contex wglMakeCurrent(dc, rc);//让gl环境生效 glewInit();//初始化glew&#125; 要是能出现这样的窗口那就大功告成了。","categories":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}],"tags":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/tags/OpenGL/"}],"keywords":[{"name":"OpenGL","slug":"OpenGL","permalink":"http://eamon.xyz/categories/OpenGL/"}]}]}